# twine_japan - Tweego + SugarCube + PWA + GitHub Pages (Option B)

Quick start:

```bash
bash scripts/get_tweego.sh
bash scripts/build.sh
# open dist/index.html
```

## Build process overview

The project is authored as Tweego-compatible `.twee` stories in `stories/` and
compiled into static HTML decks. The local build script performs the following:

1. `scripts/get_tweego.sh` downloads the Tweego binary into `.bin/` (re-used
   across runs via caching in CI).
2. `scripts/build.sh` cleans `dist/`, runs Tweego with the SugarCube format to
   produce an `index.html` for each deck, copies shared assets, injects the PWA
   service worker, and writes a directory-level index page.
3. The output under `dist/` can be opened locally or published as the static
   site.

## CSS layering and overrides

Tweego assembles each story's HTML with three tiers of styling, which layer in a
predictable order:

1. **SugarCube base theme.** Every story declares the SugarCube 2.36.1 format in
   its story metadata, and the build script points Tweego at the vendored
   `formats/` directory. SugarCube's bundled stylesheet is, therefore, the first
   set of rules applied to the passages.
2. **Shared typography tweaks.** Stories that want a common baseline import the
   repository-level stylesheet via `StoryStylesheet`. The shared file tightens up
   fonts and default spacing for Twine's `<tw-story>` element, providing a light
   layer of overrides on top of SugarCube.
3. **Story-specific presentation.** Additional `@import` rules bring in a deck's
   own `assets/styles.css`, which the build step copies next to the compiled
   story. These files introduce the heavy customizations—backgrounds, cards, and
   resets—with liberal use of `!important` where the layout needs to trump the
   upstream defaults.

Because Tweego injects the `StoryStylesheet` content as-is, the order of the
`@import` statements decides which layer wins in the cascade. Kyoto's stories
load the shared tweaks before their own file, while the Nikko deck imports only
its aggressive reset stylesheet, so it completely replaces SugarCube's look and
feel.

## Continuous integration & deployment

GitHub Actions automate the build and release flow:

- **Build Pages (Tweego + PWA)** (`.github/workflows/pages.yml`) runs on every
  pull request and push. It checks out the repository, installs Tweego, and
  executes the same build script used locally. Push events additionally clone
  the `gh-pages` branch, copy the freshly built `dist/` output into it (adding a
  `.nojekyll` marker), and regenerate the root index. Commits to non-`main`
  branches are prefixed with `z_staging_` so previews remain isolated.
- **Deploy GitHub Pages from Branch** (`.github/workflows/gh-pages-deploy.yml`)
  listens for updates to the `gh-pages` branch. It packages the branch contents
  as a Pages artifact and publishes it to the `github-pages` environment.

## Role of the `gh-pages` branch and GitHub Pages

The `gh-pages` branch holds the compiled static site that GitHub Pages serves.
Source code changes land on `main`, the build workflow refreshes the generated
files in `gh-pages`, and the deploy workflow then releases those files to GitHub
Pages. As a result, visiting the repository's GitHub Pages URL loads the latest
PWA-enabled stories that were generated by CI. The branch is not meant for
hand-edited changes; it is treated as a publish-only artifact of the automated
build pipeline.

## Current PWA status
The repository contains an explicit service worker (sw.js) that pre-caches the site shell (HTML, manifest, and icons) during installation, cleans up old cache versions on activation, and serves a network-first strategy with offline fallbacks. This demonstrates that the offline caching logic intended for the GitHub Pages output remains in place.

- A web app manifest is bundled at the site root (manifest.webmanifest), declaring the standalone display mode, theme colors, and the required icon sizes so browsers can install the site as a Progressive Web App.

- The build script injects the service worker registration snippet into every generated story page, copies the manifest and service worker into the publish directory, and writes an index page that also registers the worker. Consequently, every page published to GitHub Pages points to /sw.js, allowing the worker to control the whole site scope.

- The GitHub Actions workflow that publishes to the gh-pages branch runs the same build script and copies the generated dist/ output—including sw.js, the manifest, and icons—into the branch served by GitHub Pages, so the PWA assets reach production automatically.

- Conclusion: With these pieces still wired together, the GitHub Pages build should continue to register the service worker and provide offline caching/installability as originally intended.

How to restore it if it stops working
1. Rebuild locally using scripts/get_tweego.sh (once) followed by scripts/build.sh to ensure the dist/ folder contains the service worker, manifest, and PWA-enabled HTML output. If the sw.js or manifest files are missing, restore them from version control or recreate them based on the current design.

1. Confirm registration snippets remain in the generated HTML—each story page (and the root index) should register ../sw.js or ./sw.js respectively, as handled in scripts/build.sh. If the injection step was removed, reapply the small Python snippet in the build script that writes the <script>navigator.serviceWorker.register(...)</script> block.

1. Verify the CI workflow (.github/workflows/pages.yml) still runs the build and copies dist/ into gh-pages. If the workflow was altered or disabled, restore it so the published branch receives the service worker and manifest on every push.

1. Redeploy by pushing to the repository (or manually triggering the workflow) so GitHub Pages serves the refreshed assets.

Following these steps re-establishes the original PWA behavior if it ever regresses.
